<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: playframework | Ostia]]></title>
  <link href="http://ostia.be/blog/categories/playframework/atom.xml" rel="self"/>
  <link href="http://ostia.be/"/>
  <updated>2012-10-05T10:57:17+02:00</updated>
  <id>http://ostia.be/</id>
  <author>
    <name><![CDATA[Ben Verbeken]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dojo]]></title>
    <link href="http://ostia.be/blog/2012/10/03/dojo/"/>
    <updated>2012-10-03T13:43:00+02:00</updated>
    <id>http://ostia.be/blog/2012/10/03/dojo</id>
    <content type="html"><![CDATA[<p>The Belgian Playframework User Group held it's first coding event last wednesday: a Coding Dojo.   <br/>
The ingrediÃ«nts: 17 nice people, a decent sized room, food and drinks (thank you <a href="http://www.cegeka.be">Cegeka</a>!), and Playframework of course.</p>

<p>A Coding Dojo is an event where people gather to code and learn together. The goal of a dojo is exactly that: to code and learn, nothing more. It's about the journey, not the destination.  <br/>
Ours was a <em>Randori Kata</em>, a kind of dojo where the whole group works together to build an application in a couple of hours. We changed the format just a wee bit, but more on that later in this post.</p>

<!-- more -->


<h2>The Application</h2>

<p>The application we would build is QuickQuizz, a quiz engine for twitter. The idea is simple: Quickquizz allows quizmasters to write questions and the expected answer, Quickquizz tweets the questions on a special <a href="http://twitter.com/quickquizz">@quickquizz</a> account, and people can answer these questions by replying to the tweet. Quickquizz then fetches the answers, scores them and shows an overview of all participants and their scores on a simple overview page.</p>

<p>We managed to get most of this done on Wednesday, in about three hours (break &amp; startup included). The resulting code is on github (<a href="http://github.com/playbe/quickquizz-dojo">http://github.com/playbe/quickquizz-dojo</a>).   <br/>
Remember, if you decide to take a peek at the code, that it's all about the journey, not the destination :).</p>

<h2>The Journey</h2>

<p>The original idea was to have two people pair programming on a laptop in front of the room, with the audience following their progress on a big screen behind them, and to switch one of the pair every ten minutes.
But when I got to the cegeka offices in the afternoon to prepare the room, I noticed that the wireless keyboard &amp; mous I brought actually worked from everywhere in the room, with the laptop open in front. So what we did was: instead of moving people every ten minutes, we moved the mouse and keyboard around.</p>

<p>I think that was a game changer.</p>

<h2>Table placement</h2>

<p>The wireless keyboard thing worked. Also, the fact we were sitting around tables in a in a big U-shape clearly helped interaction.</p>

<h2>Timing: </h2>

<p>If you do a dojo, timing is important. A very obvious thing only occurred to me during the dojo: if you have 20 people, and each of them codes for 10 minutes, you need 200 minutes of coding time. We actually forgot to calculate this up front..</p>

<h2>Keyboard</h2>

<p>In a 'normal' XXX dojo, there's two people pair programing in front of the room on a laptop, while the rest of the participants follow on the big screen. Every x minutes, one of the pairs is swapped with someone from the audience, and at the end of the evening everybody should have coded at least once.</p>

<p>We did it slightly different. When I arrived at the Cegeka offices in the afternoon, the room was free so I put myself in a chair started hacking. I noticed that the wireless keyboard I brought actually worked if I moved to the back of the room.</p>

<p>The keyboard was passed along from left to right (or right to left, depending on your viewpoint). Result was that everything became very predictable: people at the end of the U knew they wouldn't have to code before some time, and the ones who coded in the beginning of the evening quickly knew their turn had passed.  <br/>
Perhaps we need to make it a bit less predictable next time.</p>

<p>When doing a dojo, make sure the first person to code knows at least a bit about the technology. It's very hard for a complete newbie to just start working</p>

<h2>IDE war</h2>

<p>It's an eternal war, and it can't be won.
Neither</p>

<p>I'm an IntelliJ fan, always been one, but I respect other people's choice (even if there really is no competition)</p>

<h2>Do mockups</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PlayBe Dojo: Play 2 & Java]]></title>
    <link href="http://ostia.be/blog/2012/09/18/playbe-first-dojo/"/>
    <updated>2012-09-18T23:28:00+02:00</updated>
    <id>http://ostia.be/blog/2012/09/18/playbe-first-dojo</id>
    <content type="html"><![CDATA[<p>Last year at Devoxx, I met Steve Chaloner (<a href="https://twitter.com/steve_objectify">@steve_objectify</a>), a Welsh expat in Belgium, and the first guy I met who had been using <a href="http://www.playframework.org">PlayFramework</a> professionally. Steve and his teammate managed to rewrite a struts 1 app that had been in development for some 4 years and that was ready for the bin. They used PlayFramework and rewrote the app in about a tenth of the original LOCs.  <br/>
Steve is also the author of Deadbolt, a widely used authorization module for both Play 1 and 2.</p>

<p>For those who don't know it: Play is a full-stack web framework for the JVM that was built from the ground up by web developers who were tired of the bloated enterprizeness of building web apps in java and decided to do something about it. It's got strongly typed templates, asset compilation, full statelessness, <em>real</em> hot reloading (it's stateless, duh), and it's part of the <a href="http://typesafe.com/stack">typesafe stack</a> of which <a href="http://www.theserverside.com/feature/Disruptive-forces-in-Java-Is-Scala-the-new-Spring-framework">some say</a> it's a <em>disruptive force</em>, like Spring used to be some time ago.   <br/>
But my personal favorite is this: change code - hit F5 - do a demo. <br/>
In short, it's the closest thing to PHP you can get as a java/JVM web dev, but without sacrificing your beloved strongly typed objects.</p>

<p>However, being a fanboy is not much fun if you're the only one, even if you're two.
So somewhere in spring - the season - Steve and I decided to get started with the <a href="http://www.play-be.org">Belgian Playframework User Group</a> (or <a href="https://twitter.com/#!/search/%23playbe">#playbe</a> for short). At this moment, the user group has about 30 members.</p>

<p>Now, a couple of months and beer sessions later, we're very proud to announce PlayBe's first <em>real</em> event: a <strong>Play2 Coding Dojo</strong>.  <br/>
A <a href="http://codingdojo.org">coding dojo</a> is a live coding event where everybody in the room is invited to participate. The format will be that of a <em>Randori Kata</em>, in which the group collectively builds an application, in our case using Play2 and Java.</p>

<p>What we'll be building is still a bit of a secret, but I promise it'll be something you can talk about at home, and maybe even use. <br/>
Also, did I mention that there'll be food and drinks? (Thanks <a href="http://www.cegeka.be">Cegeka</a> for the hosting &amp; sponsoring!).</p>

<p>The Dojo takes place <strong>3 October, 2012 at 7pm</strong>, at the <strong>Cegeka Offices</strong> in <strong>Leuven (Belgium)</strong>.  <br/>
No PlayFramework experience is required, the only thing you should be familiar with is a keyboard and some Java. We won't be doing <del>any</del> Scala.  <br/>
<a href="http://www.meetup.com/play-be/events/78580712/">Registration</a> is required, but free.</p>

<p>Hope to see you there!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Play2, SecureSocial, Heroku, and how to keep your secrets secret]]></title>
    <link href="http://ostia.be/blog/2012/09/11/securesocial-and-heroku-keep-your-secrets-secret/"/>
    <updated>2012-09-11T00:19:00+02:00</updated>
    <id>http://ostia.be/blog/2012/09/11/securesocial-and-heroku-keep-your-secrets-secret</id>
    <content type="html"><![CDATA[<p>I'm a contributor on an open source project called <a href="https://github.com/play-modules/modules.playframework.org">modules.playframework.org</a>, a public module repository for playframework that is to replace the <a href="http://www.playframework.org/modules">existing modules page</a> in the near future.
We're using the new <a href="https://github.com/jaliss/securesocial">SecureSocial</a> module for play2 by the ever  helpful Jorge (<a href="https://twitter.com/jaliss">@jaliss</a>) so that people to log in using
their twitter, facebook, google and linkedin accounts.</p>

<p>Being an open source project does mean that the source (and configuration) is out in the open. However, some things are better kept secret, such as secret api keys (if the variable name contains the word 'secret', that's a clue ;)).</p>

<p>So, we want to push our code to github without publishing the secret keys. On the other hand we also want to deploy a working app on Heroku.    <br/>
In this post I'll show you how we kept our secrets secret, without the need for a separate git branch and without sacrificing the simplicity of <code>git push heroku</code>, by splitting up our development and production configuration, and by using Heroku's environment variables.</p>

<!-- more -->


<h2>Split up configuration for development and production</h2>

<p>Play2 allows you to 'include' configuration files and to override previously defined properties.   <br/>
To keep things simple, we'll keep our development configuration in the default <code>/conf/application.conf</code> file, and override what's necessary in a separate <code>/conf/production.conf</code> file.</p>

<p>This is what our production configuration looks like:</p>

<p>``` yml production.conf</p>

<pre><code># include the default configuration
include "application.conf"  

securesocial {

    onLoginGoTo=/
    onLogoutGoTo=/

    twitter {
        requestTokenUrl="https://api.twitter.com/oauth/request_token"
        accessTokenUrl="https://api.twitter.com/oauth/access_token"
        authorizationUrl="https://api.twitter.com/oauth/authorize"
        consumerKey=${?TWITTER_CONSUMER_KEY}
        consumerSecret=${?TWITTER_CONSUMER_SECRET}
    }

    #   ... more configuration for facebook, linkedin etc. ...
}
</code></pre>

<p>```</p>

<p>Note that consumerKey and consumerSecret properties are defined as <code>${?VAR_NAME}</code>. Don't worry, that's part of the plan. Later on we'll configure those in environment variables on Heroku. The point is that the actual secrets won't be pushed to your git remotes.</p>

<p>Our <code>application.conf</code> file also configures the Secure Social module:</p>

<p>``` yml application.conf</p>

<pre><code>#   ... other usual configuration for play, such as loggers, db conf, etc. 


securesocial {

    onLoginGoTo=/
    onLogoutGoTo=/

    twitter {
        requestTokenUrl="https://api.twitter.com/oauth/request_token"
        accessTokenUrl="https://api.twitter.com/oauth/access_token"
        authorizationUrl="https://api.twitter.com/oauth/authorize"
        consumerKey=ZgO1k57cxgodmNFa8Vkfg
        consumerSecret=HVchVmadIZcZnxZdOTr1S2gkwDdk64XzY3DxWMg9Xg
    }

     google {
        authorizationUrl=WONT_WORK
        accessTokenUrl=WONT_WORK
        clientId=WONT_WORK
        clientSecret=WONT_WORK
        scope=WONT_WORK
    }

    facebook {
        authorizationUrl=WONT_WORK
        accessTokenUrl=WONT_WORK
        clientId=WONT_WORK
        clientSecret=WONT_WORK
        scope=WONT_WORK
    }

    linkedin {
        requestTokenUrl=WONT_WORK
        accessTokenUrl=WONT_WORK
        authorizationUrl=WONT_WORK
        consumerKey=WONT_WORK
        consumerSecret=WONT_WORK
    }

}
</code></pre>

<p>```</p>

<p>Two important things to note here:</p>

<ul>
<li>When running the application without loading the <code>production.conf</code> file, we'll only be able to use twitter to log in, since the google, facebook and linkedin secrets are missing here. However, we do need to 'configure' them, since Secure Social needs every provider to be loaded as a plugin in the <code>play.plugins</code> file, and that file is the same for development and production.</li>
<li>We configure the Twitter provider with keys from a twitter app that was specifically created for testing purposes, found <a href="http://foobla.com/faqs/obsocialsubmit/twitter-apps-for-testing.html">here</a>. We could've done that for the other providers as well, but we didn't.</li>
</ul>


<h2>Setup Heroku</h2>

<p>Last step: we want Heroku to tell Play to use the <code>production.conf</code> file on startup. That's what the <code>Procfile</code> is for. Just add <code>-Dconfig.resource=production.conf</code> and you're done.  <br/>
You could also load your production config from an external file or an url (see the <a href="http://www.playframework.org/documentation/2.0.3/ProductionConfiguration">docs</a>).</p>

<p>Finally, in order to make the variables in our <code>production.conf</code> resolve, you need to tell Heroku about them. Here's how:</p>

<pre><code>heroku config:add \
    TWITTER_CONSUMER_KEY=realKey \
    TWITTER_CONSUMER_SECRET=realSecret \
    other keys
</code></pre>

<p>This will set the environment variables, increase the version number of your dyno and restart it.
Story done!</p>

<h2>Final notes </h2>

<p>Splitting up your development and production configuration is obviously useful for many things: db configuration, logging, everything really.</p>

<p>Also, we found it easiest to have a default (dev) configuration and override what's necessary for production, but there are other possibilities. Whatever you do, don't over-engineer it: I know for myself I understand <em>real</em> code a lot better than configuration files. Which is what's wrong with Spring, but that's another story.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Play2, SecureSocial, Heroku, and how to keep your secrets secret]]></title>
    <link href="http://ostia.be/blog/2012/09/11/securesocial-and-heroku-keep-your-secrets-secret/"/>
    <updated>2012-09-11T00:19:00+02:00</updated>
    <id>http://ostia.be/blog/2012/09/11/securesocial-and-heroku-keep-your-secrets-secret</id>
    <content type="html"><![CDATA[<p>I'm a contributor on an open source project called <a href="https://github.com/play-modules/modules.playframework.org">modules.playframework.org</a>, a public module repository for playframework that is to replace the <a href="http://www.playframework.org/modules">existing modules page</a> in the near future.
We're using the new <a href="https://github.com/jaliss/securesocial">SecureSocial</a> module for play2 by the ever  helpful Jorge (<a href="https://twitter.com/jaliss">@jaliss</a>) so that people to log in using
their twitter, facebook, google and linkedin accounts.</p>

<p>Being an open source project does mean that the source (and configuration) is out in the open. However, some things are better kept secret, such as secret api keys (if the variable name contains the word 'secret', that's a clue ;)).</p>

<p>So, we want to push our code to github without publishing the secret keys. On the other hand we also want to deploy a working app on Heroku.    <br/>
In this post I'll show you how we kept our secrets secret, without the need for a separate git branch and without sacrificing the simplicity of <code>git push heroku</code>, by splitting up our development and production configuration, and by using Heroku's environment variables.</p>

<!-- more -->


<h2>Split up configuration for development and production</h2>

<p>Play2 allows you to 'include' configuration files and to override previously defined properties.   <br/>
To keep things simple, we'll keep our development configuration in the default <code>/conf/application.conf</code> file, and override what's necessary in a separate <code>/conf/production.conf</code> file.</p>

<p>This is what our production configuration looks like:</p>

<p>``` yml production.conf</p>

<pre><code># include the default configuration
include "application.conf"  

securesocial {

    onLoginGoTo=/
    onLogoutGoTo=/

    twitter {
        requestTokenUrl="https://api.twitter.com/oauth/request_token"
        accessTokenUrl="https://api.twitter.com/oauth/access_token"
        authorizationUrl="https://api.twitter.com/oauth/authorize"
        consumerKey=${?TWITTER_CONSUMER_KEY}
        consumerSecret=${?TWITTER_CONSUMER_SECRET}
    }

    #   ... more configuration for facebook, linkedin etc. ...
}
</code></pre>

<p>```</p>

<p>Note that consumerKey and consumerSecret properties are defined as <code>${?VAR_NAME}</code>. Don't worry, that's part of the plan. Later on we'll configure those in environment variables on Heroku. The point is that the actual secrets won't be pushed to your git remotes.</p>

<p>Our <code>application.conf</code> file also configures the Secure Social module:</p>

<p>``` yml application.conf</p>

<pre><code>#   ... other usual configuration for play, such as loggers, db conf, etc. 


securesocial {

    onLoginGoTo=/
    onLogoutGoTo=/

    twitter {
        requestTokenUrl="https://api.twitter.com/oauth/request_token"
        accessTokenUrl="https://api.twitter.com/oauth/access_token"
        authorizationUrl="https://api.twitter.com/oauth/authorize"
        consumerKey=ZgO1k57cxgodmNFa8Vkfg
        consumerSecret=HVchVmadIZcZnxZdOTr1S2gkwDdk64XzY3DxWMg9Xg
    }

     google {
        authorizationUrl=WONT_WORK
        accessTokenUrl=WONT_WORK
        clientId=WONT_WORK
        clientSecret=WONT_WORK
        scope=WONT_WORK
    }

    facebook {
        authorizationUrl=WONT_WORK
        accessTokenUrl=WONT_WORK
        clientId=WONT_WORK
        clientSecret=WONT_WORK
        scope=WONT_WORK
    }

    linkedin {
        requestTokenUrl=WONT_WORK
        accessTokenUrl=WONT_WORK
        authorizationUrl=WONT_WORK
        consumerKey=WONT_WORK
        consumerSecret=WONT_WORK
    }

}
</code></pre>

<p>```</p>

<p>Two important things to note here:</p>

<ul>
<li>When running the application without loading the <code>production.conf</code> file, we'll only be able to use twitter to log in, since the google, facebook and linkedin secrets are missing here. However, we do need to 'configure' them, since Secure Social needs every provider to be loaded as a plugin in the <code>play.plugins</code> file, and that file is the same for development and production.</li>
<li>We configure the Twitter provider with keys from a twitter app that was specifically created for testing purposes, found <a href="http://foobla.com/faqs/obsocialsubmit/twitter-apps-for-testing.html">here</a>. We could've done that for the other providers as well, but we didn't.</li>
</ul>


<h2>Setup Heroku</h2>

<p>Last step: we want Heroku to tell Play to use the <code>production.conf</code> file on startup. That's what the <code>Procfile</code> is for. Just add <code>-Dconfig.resource=production.conf</code> and you're done.  <br/>
You could also load your production config from an external file or an url (see the <a href="http://www.playframework.org/documentation/2.0.3/ProductionConfiguration">docs</a>).</p>

<p>Finally, in order to make the variables in our <code>production.conf</code> resolve, you need to tell Heroku about them. Here's how:</p>

<pre><code>heroku config:add \
    TWITTER_CONSUMER_KEY=realKey \
    TWITTER_CONSUMER_SECRET=realSecret \
    other keys
</code></pre>

<p>This will set the environment variables, increase the version number of your dyno and restart it.
Story done!</p>

<h2>Final notes </h2>

<p>Splitting up your development and production configuration is obviously useful for many things: db configuration, logging, everything really.</p>

<p>Also, we found it easiest to have a default (dev) configuration and override what's necessary for production, but there are other possibilities. Whatever you do, don't over-engineer it: I know for myself I understand <em>real</em> code a lot better than configuration files. Which is what's wrong with Spring, but that's another story.</p>
]]></content>
  </entry>
  
</feed>
